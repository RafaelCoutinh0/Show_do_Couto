<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/main_flet.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/main_flet.py" />
              <option name="originalContent" value="import os&#10;import random&#10;import traceback&#10;import flet as ft&#10;import requests&#10;import json&#10;import base64&#10;from pathlib import Path&#10;&#10;WEBHOOK_URL = &quot;https://script.google.com/macros/s/AKfycbwIVi_uiA-MFKIpwsjH9oQuLnmjxt2WOJKan5KbTYiuLCjjkkVlqbaVCga3TywM2mw_8A/exec&quot;&#10;GS_URL = &quot;https://script.google.com/macros/s/AKfycbwIVi_uiA-MFKIpwsjH9oQuLnmjxt2WOJKan5KbTYiuLCjjkkVlqbaVCga3TywM2mw_8A/exec&quot;&#10;&#10;# path para persistir acertos por usuário&#10;DB_ACERTOS_FILE = Path(__file__).parent / &quot;acertos.json&quot;&#10;&#10;def _load_acertos_db():&#10;    try:&#10;        if DB_ACERTOS_FILE.exists():&#10;            return json.loads(DB_ACERTOS_FILE.read_text(encoding=&quot;utf-8&quot;))&#10;    except Exception:&#10;        pass&#10;    return {}&#10;&#10;def _save_acertos_db(db):&#10;    try:&#10;        DB_ACERTOS_FILE.write_text(json.dumps(db, ensure_ascii=False, indent=2), encoding=&quot;utf-8&quot;)&#10;    except Exception:&#10;        pass&#10;&#10;def add_acerto_for_user(user_id, acerto_item):&#10;    &quot;&quot;&quot;Adiciona um acerto (dict) ao usuário (persistente).&quot;&quot;&quot;&#10;    if not user_id:&#10;        return&#10;    try:&#10;        db = _load_acertos_db()&#10;        lst = db.get(user_id) or []&#10;        lst.append(acerto_item)&#10;        db[user_id] = lst&#10;        _save_acertos_db(db)&#10;    except Exception:&#10;        pass&#10;&#10;def get_acertos_for_user(user_id):&#10;    if not user_id:&#10;        return []&#10;    try:&#10;        db = _load_acertos_db()&#10;        return db.get(user_id, []) or []&#10;    except Exception:&#10;        return []&#10;&#10;def hash_senha(senha: str) -&gt; str:&#10;    # NÃO usar criptografia: retornar a senha em texto puro conforme solicitado&#10;    # mantém tratamento de None e trim&#10;    s = (senha or &quot;&quot;).strip()&#10;    return s&#10;&#10;def registrar_usuario(nome, matricula, email, senha):&#10;    payload = {&#10;        &quot;action&quot;: &quot;register&quot;,&#10;        &quot;nome&quot;: (nome or &quot;&quot;).strip(),&#10;        &quot;matricula&quot;: (matricula or &quot;&quot;).strip(),&#10;        &quot;email&quot;: (email or &quot;&quot;).strip(),&#10;        &quot;senha&quot;: (senha or &quot;&quot;).strip()&#10;    }&#10;    try:&#10;        r = requests.post(GS_URL, json=payload, timeout=10)&#10;        if r.status_code != 200:&#10;            return (False, f&quot;HTTP {r.status_code}: {r.text}&quot;)&#10;        try:&#10;            data = r.json()&#10;            if isinstance(data, dict) and data.get('success') in (True, 'true', 'True', 1):&#10;                return (True, data)&#10;            msg = str(data.get('message') or '')&#10;            if 'REGISTER_OK' in msg or msg.upper() in ('OK', 'SUCCESS'):&#10;                return (True, data)&#10;            return (False, data)&#10;        except Exception:&#10;            text = (r.text or '').strip()&#10;            if 'REGISTER_OK' in text or text.upper() in ('OK','SUCCESS'):&#10;                return (True, r.text)&#10;            return (False, r.text)&#10;    except Exception as e:&#10;        return (False, str(e))&#10;&#10;&#10;def login_usuario(matricula, senha):&#10;    &quot;&quot;&quot;Tenta autenticar o usuário. Primeiro tenta GET, se não houver sucesso tenta POST.&#10;    Retorna (True, dados) em caso de sucesso, (False, mensagem) em caso de falha.&#10;    &quot;&quot;&quot;&#10;    matricula = (matricula or &quot;&quot;).strip()&#10;    senha = (senha or &quot;&quot;).strip()&#10;    params = {&#10;        &quot;action&quot;: &quot;login&quot;,&#10;        &quot;matricula&quot;: matricula,&#10;        &quot;senha&quot;: senha&#10;    }&#10;    try:&#10;        # tentativa via GET&#10;        r = requests.get(GS_URL, params=params, timeout=10)&#10;    except Exception as e_get:&#10;        r = None&#10;        err_get = str(e_get)&#10;    else:&#10;        err_get = None&#10;&#10;    def _parse_response(rsp):&#10;        # recebe um Response e decide se é sucesso&#10;        try:&#10;            if rsp is None:&#10;                return (False, &quot;Sem resposta do servidor (GET falhou).&quot;)&#10;            if rsp.status_code != 200:&#10;                return (False, f&quot;HTTP {rsp.status_code}: {rsp.text}&quot;)&#10;            # tenta JSON&#10;            try:&#10;                data = rsp.json()&#10;                # Casos comuns: { &quot;success&quot;: true }, { &quot;status&quot;: &quot;OK&quot; }, ou retorno com dados do usuário&#10;                if isinstance(data, dict):&#10;                    if data.get(&quot;success&quot;) in (True, &quot;true&quot;, &quot;True&quot;, 1) or str(data.get(&quot;status&quot;, &quot;&quot;)).upper() in (&quot;OK&quot;, &quot;SUCCESS&quot;):&#10;                        return (True, data)&#10;                    # se vier um obj usuário (ex: possui matricula/nome/email), considerar sucesso&#10;                    if any(k in data for k in (&quot;matricula&quot;, &quot;email&quot;, &quot;nome&quot;, &quot;user&quot;, &quot;id&quot;)):&#10;                        return (True, data)&#10;                    # se houver uma mensagem indicando login ok&#10;                    msg = str(data.get(&quot;message&quot;) or &quot;&quot;).upper()&#10;                    if &quot;LOGIN_OK&quot; in msg or msg in (&quot;OK&quot;, &quot;SUCCESS&quot;):&#10;                        return (True, data)&#10;                    return (False, data)&#10;                # se JSON for outro tipo, avaliar texto&#10;            except Exception:&#10;                pass&#10;            text = (rsp.text or &quot;&quot;).strip()&#10;            txt_up = text.upper()&#10;            if &quot;LOGIN_OK&quot; in txt_up or txt_up == &quot;OK&quot; or &quot;SUCCESS&quot; in txt_up:&#10;                return (True, text)&#10;            return (False, text)&#10;        except Exception as ex:&#10;            return (False, str(ex))&#10;&#10;    # tentar analisar resposta GET&#10;    ok, resp = _parse_response(r if r is not None else None)&#10;    if ok:&#10;        return (True, resp)&#10;&#10;    # se GET falhou ou não indicou sucesso, tentar POST como fallback&#10;    try:&#10;        payload = {&quot;action&quot;: &quot;login&quot;, &quot;matricula&quot;: matricula, &quot;senha&quot;: senha}&#10;        r2 = requests.post(GS_URL, json=payload, timeout=10)&#10;        ok2, resp2 = _parse_response(r2)&#10;        if ok2:&#10;            return (True, resp2)&#10;        # retornar a melhor mensagem possível (prioriza r2, depois r, depois exceção)&#10;        if r2 is not None and getattr(r2, &quot;text&quot;, None):&#10;            return (False, r2.text)&#10;    except Exception as e_post:&#10;        # se POST falhar, relatar ambos erros se existirem&#10;        msg = &quot;&quot;&#10;        if err_get:&#10;            msg += f&quot;GET erro: {err_get}. &quot;&#10;        msg += f&quot;POST erro: {str(e_post)}&quot;&#10;        return (False, msg)&#10;&#10;    # sem sucesso nos dois&#10;    if r is not None and getattr(r, &quot;text&quot;, None):&#10;        return (False, r.text)&#10;    if err_get:&#10;        return (False, err_get)&#10;    return (False, &quot;Resposta inesperada do servidor.&quot;)&#10;&#10;# Compatibilidade com cores entre versões:&#10;try:&#10;    colors = ft.colors    # versão mais nova&#10;except Exception:&#10;    try:&#10;        colors = ft.Colors  # fallback&#10;    except Exception:&#10;        colors = None  # raríssimo: fallback genérico&#10;&#10;# Import de player de áudio com fallback&#10;# flet_audio pode expor FletAudio (nomes variam entre versões)&#10;FLET_AUDIO_AVAILABLE = False&#10;try:&#10;    from flet_audio import FletAudio  # pacote flet-audio (nome comum)&#10;    FLET_AUDIO_AVAILABLE = True&#10;except Exception:&#10;    # fallback: talvez ft.Audio exista (algumas builds)&#10;    try:&#10;        _ = ft.Audio  # verifica existência&#10;        FLET_AUDIO_AVAILABLE = False  # usaremos ft.Audio como fallback ad-hoc&#10;    except Exception:&#10;        FLET_AUDIO_AVAILABLE = False&#10;&#10;# Caminhos de assets (relativos)&#10;ASSET_LOGO = &quot;logo.png&quot;&#10;ASSET_MUSICS = [&#10;    &quot;musics/music_game.mp3&quot;,&#10;    &quot;musics/pergunta1.mp3&quot;,&#10;    &quot;musics/acerto.mp3&quot;,&#10;    &quot;musics/lose.mp3&quot;,&#10;    &quot;musics/win.mp3&quot;,&#10;]&#10;&#10;&#10;class MusicaPlayer:&#10;    def __init__(self, page: ft.Page):&#10;        self.page = page&#10;        self.player = None&#10;&#10;        # Tenta criar FletAudio se disponível&#10;        try:&#10;            if 'FletAudio' in globals() and globals().get(&quot;FletAudio&quot;):&#10;                self.player = FletAudio(src=&quot;&quot;, autoplay=False)&#10;            else:&#10;                # fallback: usar ft.Audio se disponível&#10;                if hasattr(ft, &quot;Audio&quot;):&#10;                    self.player = ft.Audio(src=&quot;&quot;, autoplay=False)&#10;                else:&#10;                    self.player = None&#10;        except Exception:&#10;            self.player = None&#10;&#10;        if self.player is not None and self.player not in self.page.overlay:&#10;            try:&#10;                self.page.overlay.append(self.player)&#10;            except Exception:&#10;                pass&#10;&#10;    def tocar(self, i=0):&#10;        if not self.player:&#10;            return&#10;        try:&#10;            idx = int(i) if isinstance(i, int) else 0&#10;            idx = max(0, min(idx, len(ASSET_MUSICS) - 1))&#10;            src = ASSET_MUSICS[idx]&#10;            # garante caminho relativo (sem leading slash)&#10;            src = src.lstrip(&quot;/&quot;)&#10;            self.player.src = src&#10;            # autoplay pode não ser aceito por todas as classes; tente setar e update&#10;            try:&#10;                self.player.autoplay = True&#10;            except Exception:&#10;                pass&#10;            try:&#10;                self.page.update()&#10;            except Exception:&#10;                pass&#10;        except Exception:&#10;            # não deixar quebrar a aplicação por erro de áudio&#10;            print(&quot;Erro ao tocar áudio:&quot;, traceback.format_exc())&#10;&#10;# Removido: antiga definição de TelaRegistro que herdava ft.Column (substituída por UserControl mais acima)&#10;&#10;# Removido: antiga definição de TelaLogin que herdava ft.Column (substituída por UserControl mais acima)&#10;&#10;class ShowDoMilhao:&#10;    def __init__(self, page: ft.Page, on_logout=None, user_id=None):&#10;        self.page = page&#10;        # callback para voltar à tela de entrada (login/registro)&#10;        self.on_logout = on_logout&#10;        # user_id (matrícula ou identificador) para persistir acertos por usuário&#10;        self.user_id = user_id&#10;        try:&#10;            self.page.title = &quot;Show do Coutão&quot;&#10;            self.page.bgcolor = &quot;#002e5c&quot;&#10;        except Exception:&#10;            pass&#10;        self.musica = MusicaPlayer(page)&#10;        self.pontos = 0&#10;        self.checkpoint = 0&#10;        self.perguntas_jogo = []&#10;        self.pergunta_atual = None&#10;        self.indice = 0&#10;        self.ajuda_usada = False&#10;        self.troca_usada = False&#10;        self.ajuda_professor_usada = False&#10;        self.labels_regua = []&#10;        self.botoes = []&#10;        # Lista para armazenar as perguntas que o jogador já acertou&#10;        # carregar acertos persistidos do usuário (se houver)&#10;        if self.user_id:&#10;            self.perguntas_acertadas = list(get_acertos_for_user(self.user_id))&#10;        else:&#10;            self.perguntas_acertadas = []&#10;        self.tela_inicial()&#10;&#10;    # helpers para compatibilidade de ButtonStyle entre versões&#10;    def _make_button_style(self):&#10;        # Tentamos usar text_style (nova API). Se der TypeError, tentamos textstyle.&#10;        try:&#10;            return ft.ButtonStyle(&#10;                text_style=ft.TextStyle(size=28, weight=ft.FontWeight.BOLD)&#10;            )&#10;        except TypeError:&#10;            try:&#10;                return ft.ButtonStyle(&#10;                    textstyle=ft.TextStyle(size=28, weight=ft.FontWeight.BOLD)&#10;                )&#10;            except Exception:&#10;                # fallback simples&#10;                return None&#10;        except Exception:&#10;            return None&#10;&#10;    def tela_inicial(self):&#10;        try:&#10;            self.musica.tocar(0)&#10;        except Exception:&#10;            pass&#10;        self.page.clean()&#10;        # garantir estado inicial limpo&#10;&#10;        # tenta embutir a imagem como data URI para garantir exibição&#10;        def _get_logo_src():&#10;            try:&#10;                p = Path(ASSET_LOGO)&#10;                if p.exists():&#10;                    b = p.read_bytes()&#10;                    mime = &quot;image/png&quot;&#10;                    # inferir por extensão simples&#10;                    if p.suffix.lower() in [&quot;.jpg&quot;, &quot;.jpeg&quot;]:&#10;                        mime = &quot;image/jpeg&quot;&#10;                    elif p.suffix.lower() == &quot;.gif&quot;:&#10;                        mime = &quot;image/gif&quot;&#10;                    data = base64.b64encode(b).decode(&quot;ascii&quot;)&#10;                    return f&quot;data:{mime};base64,{data}&quot;&#10;            except Exception:&#10;                pass&#10;            # fallback: caminho direto (requer assets_dir configurado)&#10;            return ASSET_LOGO&#10;&#10;        # aumentar tamanho do logo&#10;        logo = ft.Image(src=_get_logo_src(), width=900, height=450, fit=ft.ImageFit.CONTAIN)&#10;        botao_style = self._make_button_style()&#10;        botao_jogar = ft.ElevatedButton(&#10;            &quot;Jogar&quot;,&#10;            on_click=self.iniciar_jogo,&#10;            bgcolor=(colors.BLUE if colors is not None else None),&#10;            color=(colors.WHITE if colors is not None else None),&#10;            width=300,&#10;            height=70,&#10;            style=botao_style&#10;        )&#10;        # &quot;Sair&quot; deve apenas deslogar: chamar on_logout para voltar ao login/registro&#10;        def _sair_inicial(e):&#10;            # tenta chamar callback de logout, se fornecido&#10;            try:&#10;                if callable(getattr(self, &quot;on_logout&quot;, None)):&#10;                    return self.on_logout()&#10;            except Exception:&#10;                pass&#10;            # fallback: limpar e mostrar uma tela simples que retorna para tela_inicial&#10;            try:&#10;                self.page.clean()&#10;            except Exception:&#10;                pass&#10;            try:&#10;                col = ft.Column(&#10;                    [&#10;                        ft.Text(&quot;Você saiu do jogo&quot;, size=20, weight=ft.FontWeight.BOLD),&#10;                        ft.ElevatedButton(&quot;Voltar&quot;, on_click=lambda ev: self.tela_inicial(), width=220)&#10;                    ],&#10;                    alignment=ft.MainAxisAlignment.CENTER,&#10;                    horizontal_alignment=ft.CrossAxisAlignment.CENTER,&#10;                    spacing=16&#10;                )&#10;                self.page.add(ft.Container(content=col, alignment=ft.alignment.center, expand=True))&#10;                try:&#10;                    self.page.update()&#10;                except Exception:&#10;                    pass&#10;            except Exception:&#10;                # evitar crash caso o fallback falhe&#10;                pass&#10;&#10;        botao_sair = ft.ElevatedButton(&#10;            &quot;Sair&quot;,&#10;            on_click=_sair_inicial,&#10;            bgcolor=(colors.RED if colors is not None else None),&#10;            color=(colors.WHITE if colors is not None else None),&#10;            width=300,&#10;            height=70,&#10;            style=botao_style&#10;        )&#10;&#10;        botao_minhas = None&#10;        if getattr(self, &quot;user_id&quot;, None):&#10;            botao_minhas = ft.ElevatedButton(&#10;                &quot;Minhas Respostas&quot;,&#10;                on_click=self.mostrar_acertos,&#10;                bgcolor=(colors.BROWN if colors is not None else None),&#10;                color=(colors.WHITE if colors is not None else None),&#10;                width=300,&#10;                height=70&#10;            )&#10;&#10;        # montar linha de botões: se houver botao_minhas, incluí-lo entre Jogar e Sair&#10;        row_buttons = [botao_jogar]&#10;        if botao_minhas:&#10;            row_buttons.append(botao_minhas)&#10;        row_buttons.append(botao_sair)&#10;&#10;        col = ft.Column([&#10;            logo,&#10;            ft.Row(row_buttons, alignment=ft.MainAxisAlignment.CENTER)&#10;        ], alignment=ft.MainAxisAlignment.CENTER, horizontal_alignment=ft.CrossAxisAlignment.CENTER, spacing=24)&#10;        # envolver em Container expandido para centralizar também verticalmente&#10;        self.page.add(ft.Container(content=col, alignment=ft.alignment.center, expand=True))&#10;&#10;    def iniciar_jogo(self, e=None):&#10;        import traceback as _tb&#10;        print(&quot;[DEBUG] iniciar_jogo chamado&quot;)&#10;        try:&#10;            try:&#10;                self.musica.tocar(1)&#10;            except Exception:&#10;                pass&#10;            self.pontos = 0&#10;            # NÃO resetar persistência global dos acertos do usuário; manter histórico&#10;            # inicia jogo: limpar página e construir a interface do jogo&#10;            try:&#10;                self.page.clean()&#10;            except Exception:&#10;                pass&#10;            self.ajuda_usada = False&#10;            self.troca_usada = False&#10;            self.ajuda_professor_usada = False&#10;            # importa perguntas dinamicamente para evitar import circular no topo&#10;            try:&#10;                from perguntas import facil&#10;                self.perguntas_jogo = random.sample(facil, min(10, len(facil)))&#10;            except Exception:&#10;                self.perguntas_jogo = []&#10;            self.tela_jogo()&#10;        except Exception as exc:&#10;            tb = _tb.format_exc()&#10;            print(&quot;[ERROR] Exception em iniciar_jogo:\n&quot;, tb)&#10;            # mostra diálogo com erro para evitar tela cinza&#10;            try:&#10;                dlg = ft.AlertDialog(title=ft.Text(&quot;Erro ao iniciar jogo&quot;), content=ft.Text(&quot;Ocorreu um erro ao iniciar o jogo. Veja o console.&quot;), actions=[ft.TextButton(&quot;OK&quot;, on_click=lambda e: self._fechar_dialog(dlg))])&#10;                self.page.dialog = dlg&#10;                if dlg not in self.page.overlay:&#10;                    self.page.overlay.append(dlg)&#10;                dlg.open = True&#10;                try:&#10;                    self.page.update()&#10;                except Exception:&#10;                    pass&#10;            except Exception:&#10;                pass&#10;            return&#10;&#10;    def tela_jogo(self):&#10;        self.page.clean()&#10;        self.labels_regua = []&#10;        regua = []&#10;        for i in range(len(self.perguntas_jogo)):&#10;            texto = f&quot;{i + 1}&quot;&#10;            icone = &quot;&quot;&#10;            cor_fundo = (colors.BLUE_900 if colors is not None else None)&#10;            cor_texto = (colors.WHITE if colors is not None else None)&#10;            bolinha = ft.Container(&#10;                content=ft.Text(texto, size=16, color=cor_texto, weight=ft.FontWeight.BOLD),&#10;                width=36,&#10;                height=36,&#10;                bgcolor=cor_fundo,&#10;                border=ft.border.all(3, (colors.YELLOW if (colors is not None) else None)),&#10;                border_radius=18,&#10;                alignment=ft.alignment.center,&#10;                margin=ft.margin.only(right=0)&#10;            )&#10;            if i + 1 in [3, 5, 8]:&#10;                icone = &quot;&quot;&#10;            elif i + 1 == 10:&#10;                icone = &quot;&quot;&#10;            item = ft.Row([&#10;                bolinha,&#10;                ft.Text(icone, size=18, color=cor_texto) if icone else ft.Text(&quot;&quot;)&#10;            ], alignment=ft.MainAxisAlignment.CENTER, spacing=2)&#10;            regua.append(item)&#10;        self.labels_regua = regua&#10;        self.label_pergunta = ft.Text(&quot;&quot;, size=18, color=(colors.YELLOW if colors is not None else None), weight=ft.FontWeight.BOLD)&#10;        self.botoes = []&#10;        for i in range(4):&#10;            botao = ft.ElevatedButton(&#10;                &quot;...&quot;,&#10;                width=500,&#10;                bgcolor=(colors.BLUE if colors is not None else None),&#10;                color=(colors.WHITE if colors is not None else None),&#10;                on_click=lambda e, i=i: self.verificar_resposta(i)&#10;            )&#10;            self.botoes.append(botao)&#10;        self.label_feedback = ft.Text(&quot;&quot;, size=16, color=(colors.WHITE if colors is not None else None))&#10;        self.label_saldo = ft.Text(f&quot;Saldo atual: R${self.pontos}&quot;, size=16, color=(colors.CYAN if colors is not None else None))&#10;        self.botao_ajuda = ft.ElevatedButton(&#10;            &quot;Rodar Dados&quot;,&#10;            bgcolor=(colors.PURPLE if colors is not None else None),&#10;            color=(colors.WHITE if colors is not None else None),&#10;            width=160,&#10;            on_click=self.ajuda_dado&#10;        )&#10;        self.botao_troca = ft.ElevatedButton(&#10;            &quot;Trocar Pergunta&quot;,&#10;            bgcolor=(colors.GREEN_900 if colors is not None else None),&#10;            color=(colors.WHITE if colors is not None else None),&#10;            width=160,&#10;            on_click=self.trocar_pergunta&#10;        )&#10;        self.botao_professor = ft.ElevatedButton(&#10;            &quot;Ajuda dos Professores&quot;,&#10;            bgcolor=(colors.ORANGE_900 if colors is not None else None),&#10;            color=(colors.WHITE if colors is not None else None),&#10;            width=160,&#10;            on_click=self.ajuda_professor&#10;        )&#10;&#10;        # Sair deve apenas deslogar: chamar on_logout para voltar ao login/registro&#10;        def _sair_jogo(e):&#10;            # tenta executar callback de logout, se fornecido&#10;            try:&#10;                if callable(getattr(self, &quot;on_logout&quot;, None)):&#10;                    return self.on_logout()&#10;            except Exception:&#10;                pass&#10;            # fallback: limpar e mostrar uma tela simples que retorna para tela_inicial&#10;            try:&#10;                self.page.clean()&#10;            except Exception:&#10;                pass&#10;            try:&#10;                col = ft.Column(&#10;                    [&#10;                        ft.Text(&quot;Você saiu do jogo&quot;, size=20, weight=ft.FontWeight.BOLD),&#10;                        ft.ElevatedButton(&quot;Voltar&quot;, on_click=lambda ev: self.tela_inicial(), width=220)&#10;                    ],&#10;                    alignment=ft.MainAxisAlignment.CENTER,&#10;                    horizontal_alignment=ft.CrossAxisAlignment.CENTER,&#10;                    spacing=16&#10;                )&#10;                self.page.add(ft.Container(content=col, alignment=ft.alignment.center, expand=True))&#10;                try:&#10;                    self.page.update()&#10;                except Exception:&#10;                    pass&#10;            except Exception:&#10;                # evitar crash caso o fallback falhe&#10;                pass&#10;&#10;        self.botao_sair = ft.ElevatedButton(&quot;Sair&quot;, bgcolor=(colors.RED if colors is not None else None), color=(colors.WHITE if colors is not None else None), on_click=_sair_jogo)&#10;        self.botao_desistir = ft.ElevatedButton(&quot;Desistir&quot;, on_click=self.desistir)&#10;        self.page.add(&#10;            ft.Row([&#10;                ft.Column([&#10;                    self.label_pergunta,&#10;                    *self.botoes,&#10;                    # ajudas (sem o botão &quot;Minhas Respostas&quot;, que fica na tela inicial)&#10;                    ft.Row([self.botao_ajuda, self.botao_troca, self.botao_professor]),&#10;                    self.label_feedback,&#10;                    self.label_saldo,&#10;                    ft.Row([self.botao_desistir, self.botao_sair]),&#10;                ], alignment=ft.MainAxisAlignment.START),&#10;                ft.Column(regua, alignment=ft.MainAxisAlignment.START, spacing=0)&#10;            ], alignment=ft.MainAxisAlignment.CENTER)&#10;        )&#10;        self.carregar_pergunta()&#10;&#10;    def mostrar_acertos(self, e=None):&#10;        &quot;&quot;&quot;Mostra uma tela com as perguntas já acertadas e o conteúdo da ajuda do professor.&#10;        Usa os acertos persistidos do usuário (se houver user_id).&quot;&quot;&quot;&#10;        try:&#10;            self.page.clean()&#10;        except Exception:&#10;            pass&#10;        controls = []&#10;        # carregar acertos persistidos (prioriza armazenamento persistente)&#10;        acertos = self.perguntas_acertadas&#10;        if self.user_id:&#10;            try:&#10;                acertos = get_acertos_for_user(self.user_id) or []&#10;            except Exception:&#10;                pass&#10;        if not acertos:&#10;            controls.append(ft.Text(&quot;Nenhuma pergunta acertada ainda.&quot;, size=18, color=(colors.WHITE if colors is not None else None)))&#10;        else:&#10;            for idx, item in enumerate(acertos, start=1):&#10;                texto_pergunta = item.get(&quot;pergunta&quot;, &quot;Pergunta sem texto&quot;)&#10;                texto_ajuda = item.get(&quot;ajuda&quot;, &quot;Sem ajuda disponível.&quot;)&#10;                texto_correta = item.get(&quot;correta_texto&quot;, &quot;&quot;)&#10;                bloco = ft.Container(&#10;                    content=ft.Column([&#10;                        ft.Text(f&quot;{idx}. {texto_pergunta}&quot;, size=16, weight=ft.FontWeight.BOLD, selectable=True),&#10;                        ft.Text(f&quot;Resposta correta: {texto_correta}&quot;, size=14, color=(colors.CYAN if colors is not None else None)),&#10;                        ft.Text(f&quot;Ajuda dos Professores: {texto_ajuda}&quot;, size=14, selectable=True)&#10;                    ], spacing=6),&#10;                    padding=ft.padding.all(10),&#10;                    margin=ft.margin.only(bottom=8),&#10;                    bgcolor=(colors.BLUE_950 if colors is not None else None)&#10;                )&#10;                controls.append(bloco)&#10;&#10;        botao_voltar = ft.ElevatedButton(&quot;Voltar ao jogo&quot;, on_click=lambda _: self.tela_jogo(), width=200)&#10;        self.page.add(&#10;            ft.Container(&#10;                content=ft.Column(&#10;                    [ft.Text(&quot;Minhas Respostas&quot;, size=22, weight=ft.FontWeight.BOLD), *controls, botao_voltar],&#10;                    alignment=ft.MainAxisAlignment.START,&#10;                    spacing=12&#10;                ),&#10;                padding=ft.padding.all(20),&#10;                expand=True,&#10;                alignment=ft.alignment.center&#10;            )&#10;        )&#10;        try:&#10;            self.page.update()&#10;        except Exception:&#10;            pass&#10;&#10;    # helpers de texto para dividir questão/ajuda&#10;    def dividir_pergunta(self, texto, limite=90):&#10;        if len(texto) &lt;= limite:&#10;            return texto, &quot;&quot;&#10;        idx = texto.rfind(&quot; &quot;, 0, limite)&#10;        if idx == -1:&#10;            idx = limite&#10;        return texto[:idx], texto[idx:].lstrip()&#10;&#10;    def dividir_ajuda(self, texto, limite=60):&#10;        if len(texto) &lt;= limite:&#10;            return texto&#10;        idx = texto.rfind(&quot; &quot;, 0, limite)&#10;        if idx == -1:&#10;            idx = limite&#10;        return texto[:idx] + &quot;\n&quot; + texto[idx:].lstrip()&#10;&#10;    def carregar_pergunta(self):&#10;        try:&#10;            self.musica.tocar(1)&#10;        except Exception:&#10;            pass&#10;        if self.indice &lt; len(self.perguntas_jogo):&#10;            self.pergunta_atual = self.perguntas_jogo[self.indice]&#10;            alternativas = self.pergunta_atual[&quot;alternativas&quot;][:]&#10;            correta = self.pergunta_atual[&quot;correta&quot;]&#10;            alternativas_com_indices = list(enumerate(alternativas))&#10;            random.shuffle(alternativas_com_indices)&#10;            alternativas_embaralhadas = [alt for idx, alt in alternativas_com_indices]&#10;            # novo índice da correta após embaralhar&#10;            nova_correta = [idx for idx, alt in alternativas_com_indices].index(correta)&#10;            self.pergunta_atual[&quot;alternativas_embaralhadas&quot;] = alternativas_embaralhadas&#10;            self.pergunta_atual[&quot;nova_correta&quot;] = nova_correta&#10;            texto1, texto2 = self.dividir_pergunta(self.pergunta_atual[&quot;pergunta&quot;], limite=500)&#10;            texto_completo = texto1 + (&quot;\n&quot; + texto2 if texto2 else &quot;&quot;)&#10;            pergunta_principal = ft.Container(&#10;                content=ft.Text(texto_completo, size=18, color=(colors.YELLOW if colors is not None else None), weight=ft.FontWeight.BOLD, selectable=True),&#10;                width=500,&#10;                alignment=ft.alignment.center,&#10;                padding=ft.padding.all(10),&#10;                bgcolor=None&#10;            )&#10;            self.label_pergunta = pergunta_principal&#10;            for i, alt in enumerate(alternativas_embaralhadas):&#10;                self.botoes[i].text = alt&#10;                self.botoes[i].disabled = False&#10;            self.label_feedback.value = &quot;&quot;&#10;            self.label_saldo.value = f&quot;Saldo atual: R${self.pontos}&quot;&#10;            for i, item in enumerate(self.labels_regua):&#10;                bolinha = item.controls[0]&#10;                try:&#10;                    bolinha.bgcolor = (colors.GREEN_700 if i &lt; self.indice else (colors.YELLOW_300 if i == self.indice else colors.BLUE_900))&#10;                    bolinha.border = ft.border.all(3, (colors.YELLOW if i == self.indice else colors.WHITE))&#10;                    bolinha.content.color = (colors.BLACK if i == self.indice else colors.WHITE)&#10;                except Exception:&#10;                    pass&#10;            self.page.clean()&#10;            self.page.add(&#10;                ft.Row([&#10;                    ft.Column([&#10;                        self.label_pergunta,&#10;                        *self.botoes,&#10;                        # incluir o botão de acertos ao lado das ajudas&#10;                        ft.Row([self.botao_ajuda, self.botao_troca, self.botao_professor]),&#10;                        self.label_feedback,&#10;                        self.label_saldo,&#10;                        ft.Row([self.botao_desistir, self.botao_sair]),&#10;                    ], alignment=ft.MainAxisAlignment.START),&#10;                    ft.Column(self.labels_regua, alignment=ft.MainAxisAlignment.START, spacing=0)&#10;                ], alignment=ft.MainAxisAlignment.CENTER)&#10;            )&#10;            try:&#10;                self.page.update()&#10;            except Exception:&#10;                pass&#10;        else:&#10;            self.vitoria()&#10;&#10;    def trocar_pergunta(self, e=None):&#10;        if self.troca_usada:&#10;            return&#10;        self.troca_usada = True&#10;        try:&#10;            self.botao_troca.visible = False&#10;            self.page.update()&#10;        except Exception:&#10;            pass&#10;        try:&#10;            from perguntas import facil&#10;            perguntas_possiveis = [p for p in facil if p not in self.perguntas_jogo]&#10;        except Exception:&#10;            perguntas_possiveis = []&#10;        if perguntas_possiveis:&#10;            nova_pergunta = random.choice(perguntas_possiveis)&#10;            self.perguntas_jogo[self.indice] = nova_pergunta&#10;            self.label_feedback.value = &quot; Pergunta trocada!&quot;&#10;            try:&#10;                self.label_feedback.color = (colors.GREEN_900 if colors is not None else None)&#10;            except Exception:&#10;                pass&#10;            self.carregar_pergunta()&#10;        else:&#10;            self.label_feedback.value = &quot;Não há perguntas disponíveis para troca.&quot;&#10;            try:&#10;                self.label_feedback.color = colors.RED&#10;            except Exception:&#10;                pass&#10;        try:&#10;            self.page.update()&#10;        except Exception:&#10;            pass&#10;&#10;    def ajuda_dado(self, e=None):&#10;        if self.ajuda_usada:&#10;            return&#10;        self.ajuda_usada = True&#10;        try:&#10;            self.botao_ajuda.visible = False&#10;            self.page.update()&#10;        except Exception:&#10;            pass&#10;        correta = self.pergunta_atual[&quot;nova_correta&quot;]&#10;        alternativas_restantes = [i for i in range(4) if i != correta and not self.botoes[i].disabled]&#10;        qtd_eliminar = min(random.randint(1, 3), len(alternativas_restantes))&#10;        eliminar = random.sample(alternativas_restantes, qtd_eliminar)&#10;        for i in eliminar:&#10;            self.botoes[i].disabled = True&#10;            self.botoes[i].text = &quot; &quot;&#10;        self.label_feedback.value = f&quot; Dado rolado: {qtd_eliminar} alternativas eliminadas.&quot;&#10;        try:&#10;            self.label_feedback.color = (colors.PURPLE if colors is not None else None)&#10;        except Exception:&#10;            pass&#10;        try:&#10;            self.page.update()&#10;        except Exception:&#10;            pass&#10;&#10;    def ajuda_professor(self, e=None):&#10;        if self.ajuda_professor_usada:&#10;            return&#10;        self.ajuda_professor_usada = True&#10;        try:&#10;            self.botao_professor.visible = False&#10;            self.page.update()&#10;        except Exception:&#10;            pass&#10;        texto_ajuda = self.pergunta_atual.get(&quot;ajuda&quot;, &quot;‍ Os professores sugerem que você pense bem antes de responder!&quot;)&#10;        texto_ajuda = self.dividir_ajuda(texto_ajuda, limite=38)&#10;        self.label_feedback.value = f&quot;‍ Ajuda dos Professores: {texto_ajuda}&quot;&#10;        try:&#10;            self.label_feedback.color = (colors.RED if colors is not None else None)&#10;        except Exception:&#10;            pass&#10;        try:&#10;            self.page.update()&#10;        except Exception:&#10;            pass&#10;&#10;    def verificar_resposta(self, escolha):&#10;        for botao in self.botoes:&#10;            botao.disabled = True&#10;        try:&#10;            correta = int(self.pergunta_atual[&quot;nova_correta&quot;])&#10;        except Exception:&#10;            correta = None&#10;        if correta is None:&#10;            # não sabemos a correta; apenas avançar para próxima pergunta&#10;            try:&#10;                self.label_feedback.value = &quot;Erro interno: pergunta sem alternativa correta.&quot;&#10;            except Exception:&#10;                pass&#10;            try:&#10;                self.page.update()&#10;            except Exception:&#10;                pass&#10;            return&#10;&#10;        if escolha == correta:&#10;            try:&#10;                self.musica.tocar(2)&#10;            except Exception:&#10;                pass&#10;            # registrar pergunta acertada (guarda texto da pergunta, ajuda e texto da resposta correta)&#10;            try:&#10;                correta_texto = &quot;&quot;&#10;                if isinstance(self.pergunta_atual.get(&quot;alternativas&quot;), list) and isinstance(self.pergunta_atual.get(&quot;correta&quot;), int):&#10;                    correta_texto = self.pergunta_atual[&quot;alternativas&quot;][self.pergunta_atual[&quot;correta&quot;]]&#10;                acerto_item = {&#10;                    &quot;pergunta&quot;: self.pergunta_atual.get(&quot;pergunta&quot;, &quot;&quot;),&#10;                    &quot;ajuda&quot;: self.pergunta_atual.get(&quot;ajuda&quot;, &quot;&quot;),&#10;                    &quot;correta_texto&quot;: correta_texto&#10;                }&#10;                self.perguntas_acertadas.append(acerto_item)&#10;                try:&#10;                    if self.user_id:&#10;                        add_acerto_for_user(self.user_id, acerto_item)&#10;                except Exception:&#10;                    pass&#10;            except Exception:&#10;                pass&#10;&#10;            self.pontos += 1000&#10;            if (self.indice + 1) in [3, 5, 8]:&#10;                self.checkpoint = self.pontos&#10;            try:&#10;                self.label_feedback.value = f&quot;✅ Correto! Ganhou R$1000&quot;&#10;            except Exception:&#10;                pass&#10;            # avançar para próxima pergunta&#10;            self.indice += 1&#10;            if self.indice &lt; len(self.perguntas_jogo):&#10;                try:&#10;                    self.carregar_pergunta()&#10;                except Exception:&#10;                    pass&#10;            else:&#10;                try:&#10;                    self.vitoria()&#10;                except Exception:&#10;                    pass&#10;        else:&#10;            # resposta incorreta: acionar rotina de derrota/atraso se existir&#10;            try:&#10;                self.page.run_task(self._delay_derrota)&#10;            except Exception:&#10;                try:&#10;                    # fallback síncrono&#10;                    self._delay_derrota()&#10;                except Exception:&#10;                    pass&#10;        try:&#10;            self.page.update()&#10;        except Exception:&#10;            pass&#10;&#10;{ &#10;# Adicionado: entrypoint e inicialização do servidor Flet (útil para deployment em Railway)&#10;def main(page: ft.Page):&#10;    &quot;&quot;&quot;&#10;    Entrypoint para Flet. Cria a instância do jogo e exibe a tela inicial.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Opcional: definir título/cores padrão se necessário&#10;        try:&#10;            page.title = &quot;Show do Coutão (Servidor)&quot;&#10;            page.bgcolor = &quot;#002e5c&quot;&#10;        except Exception:&#10;            pass&#10;&#10;        # Cria a aplicação do jogo; ShowDoMilhao já executa tela_inicial no construtor&#10;        ShowDoMilhao(page)&#10;        try:&#10;            page.update()&#10;        except Exception:&#10;            pass&#10;    except Exception as e:&#10;        # Log para diagnosticar problemas de startup&#10;        print(&quot;Erro durante inicialização da UI:&quot;, str(e))&#10;        import traceback&#10;        print(traceback.format_exc())&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    # Porta que o Railway (ou outro PaaS) fornece via env var PORT&#10;    try:&#10;        port_env = os.environ.get(&quot;PORT&quot;) or os.environ.get(&quot;PORT0&quot;) or &quot;8550&quot;&#10;        port = int(port_env)&#10;    except Exception:&#10;        port = 8550&#10;&#10;    assets = str(Path(__file__).parent)&#10;&#10;    print(f&quot;Iniciando Flet app em 0.0.0.0:{port} com assets_dir={assets}&quot;)&#10;    try:&#10;        ft.app(&#10;            target=main,&#10;            view=ft.WEB_BROWSER,&#10;            host=&quot;0.0.0.0&quot;,&#10;            port=port,&#10;            assets_dir=assets&#10;        )&#10;    except Exception as e:&#10;        print(&quot;Falha ao iniciar ft.app():&quot;, str(e))&#10;        import traceback&#10;        print(traceback.format_exc())&#10;}&#10;" />
              <option name="updatedContent" value="import os&#10;import random&#10;import traceback&#10;import flet as ft&#10;import requests&#10;import json&#10;import base64&#10;from pathlib import Path&#10;&#10;WEBHOOK_URL = &quot;https://script.google.com/macros/s/AKfycbwIVi_uiA-MFKIpwsjH9oQuLnmjxt2WOJKan5KbTYiuLCjjkkVlqbaVCga3TywM2mw_8A/exec&quot;&#10;GS_URL = &quot;https://script.google.com/macros/s/AKfycbwIVi_uiA-MFKIpwsjH9oQuLnmjxt2WOJKan5KbTYiuLCjjkkVlqbaVCga3TywM2mw_8A/exec&quot;&#10;&#10;# path para persistir acertos por usuário&#10;DB_ACERTOS_FILE = Path(__file__).parent / &quot;acertos.json&quot;&#10;&#10;def _load_acertos_db():&#10;    try:&#10;        if DB_ACERTOS_FILE.exists():&#10;            return json.loads(DB_ACERTOS_FILE.read_text(encoding=&quot;utf-8&quot;))&#10;    except Exception:&#10;        pass&#10;    return {}&#10;&#10;def _save_acertos_db(db):&#10;    try:&#10;        DB_ACERTOS_FILE.write_text(json.dumps(db, ensure_ascii=False, indent=2), encoding=&quot;utf-8&quot;)&#10;    except Exception:&#10;        pass&#10;&#10;def add_acerto_for_user(user_id, acerto_item):&#10;    &quot;&quot;&quot;Adiciona um acerto (dict) ao usuário (persistente).&quot;&quot;&quot;&#10;    if not user_id:&#10;        return&#10;    try:&#10;        db = _load_acertos_db()&#10;        lst = db.get(user_id) or []&#10;        lst.append(acerto_item)&#10;        db[user_id] = lst&#10;        _save_acertos_db(db)&#10;    except Exception:&#10;        pass&#10;&#10;def get_acertos_for_user(user_id):&#10;    if not user_id:&#10;        return []&#10;    try:&#10;        db = _load_acertos_db()&#10;        return db.get(user_id, []) or []&#10;    except Exception:&#10;        return []&#10;&#10;def hash_senha(senha: str) -&gt; str:&#10;    # NÃO usar criptografia: retornar a senha em texto puro conforme solicitado&#10;    # mantém tratamento de None e trim&#10;    s = (senha or &quot;&quot;).strip()&#10;    return s&#10;&#10;def registrar_usuario(nome, matricula, email, senha):&#10;    payload = {&#10;        &quot;action&quot;: &quot;register&quot;,&#10;        &quot;nome&quot;: (nome or &quot;&quot;).strip(),&#10;        &quot;matricula&quot;: (matricula or &quot;&quot;).strip(),&#10;        &quot;email&quot;: (email or &quot;&quot;).strip(),&#10;        &quot;senha&quot;: (senha or &quot;&quot;).strip()&#10;    }&#10;    try:&#10;        r = requests.post(GS_URL, json=payload, timeout=10)&#10;        if r.status_code != 200:&#10;            return (False, f&quot;HTTP {r.status_code}: {r.text}&quot;)&#10;        try:&#10;            data = r.json()&#10;            if isinstance(data, dict) and data.get('success') in (True, 'true', 'True', 1):&#10;                return (True, data)&#10;            msg = str(data.get('message') or '')&#10;            if 'REGISTER_OK' in msg or msg.upper() in ('OK', 'SUCCESS'):&#10;                return (True, data)&#10;            return (False, data)&#10;        except Exception:&#10;            text = (r.text or '').strip()&#10;            if 'REGISTER_OK' in text or text.upper() in ('OK','SUCCESS'):&#10;                return (True, r.text)&#10;            return (False, r.text)&#10;    except Exception as e:&#10;        return (False, str(e))&#10;&#10;&#10;def login_usuario(matricula, senha):&#10;    &quot;&quot;&quot;Tenta autenticar o usuário. Primeiro tenta GET, se não houver sucesso tenta POST.&#10;    Retorna (True, dados) em caso de sucesso, (False, mensagem) em caso de falha.&#10;    &quot;&quot;&quot;&#10;    matricula = (matricula or &quot;&quot;).strip()&#10;    senha = (senha or &quot;&quot;).strip()&#10;    params = {&#10;        &quot;action&quot;: &quot;login&quot;,&#10;        &quot;matricula&quot;: matricula,&#10;        &quot;senha&quot;: senha&#10;    }&#10;    try:&#10;        # tentativa via GET&#10;        r = requests.get(GS_URL, params=params, timeout=10)&#10;    except Exception as e_get:&#10;        r = None&#10;        err_get = str(e_get)&#10;    else:&#10;        err_get = None&#10;&#10;    def _parse_response(rsp):&#10;        # recebe um Response e decide se é sucesso&#10;        try:&#10;            if rsp is None:&#10;                return (False, &quot;Sem resposta do servidor (GET falhou).&quot;)&#10;            if rsp.status_code != 200:&#10;                return (False, f&quot;HTTP {rsp.status_code}: {rsp.text}&quot;)&#10;            # tenta JSON&#10;            try:&#10;                data = rsp.json()&#10;                # Casos comuns: { &quot;success&quot;: true }, { &quot;status&quot;: &quot;OK&quot; }, ou retorno com dados do usuário&#10;                if isinstance(data, dict):&#10;                    if data.get(&quot;success&quot;) in (True, &quot;true&quot;, &quot;True&quot;, 1) or str(data.get(&quot;status&quot;, &quot;&quot;)).upper() in (&quot;OK&quot;, &quot;SUCCESS&quot;):&#10;                        return (True, data)&#10;                    # se vier um obj usuário (ex: possui matricula/nome/email), considerar sucesso&#10;                    if any(k in data for k in (&quot;matricula&quot;, &quot;email&quot;, &quot;nome&quot;, &quot;user&quot;, &quot;id&quot;)):&#10;                        return (True, data)&#10;                    # se houver uma mensagem indicando login ok&#10;                    msg = str(data.get(&quot;message&quot;) or &quot;&quot;).upper()&#10;                    if &quot;LOGIN_OK&quot; in msg or msg in (&quot;OK&quot;, &quot;SUCCESS&quot;):&#10;                        return (True, data)&#10;                    return (False, data)&#10;                # se JSON for outro tipo, avaliar texto&#10;            except Exception:&#10;                pass&#10;            text = (rsp.text or &quot;&quot;).strip()&#10;            txt_up = text.upper()&#10;            if &quot;LOGIN_OK&quot; in txt_up or txt_up == &quot;OK&quot; or &quot;SUCCESS&quot; in txt_up:&#10;                return (True, text)&#10;            return (False, text)&#10;        except Exception as ex:&#10;            return (False, str(ex))&#10;&#10;    # tentar analisar resposta GET&#10;    ok, resp = _parse_response(r if r is not None else None)&#10;    if ok:&#10;        return (True, resp)&#10;&#10;    # se GET falhou ou não indicou sucesso, tentar POST como fallback&#10;    try:&#10;        payload = {&quot;action&quot;: &quot;login&quot;, &quot;matricula&quot;: matricula, &quot;senha&quot;: senha}&#10;        r2 = requests.post(GS_URL, json=payload, timeout=10)&#10;        ok2, resp2 = _parse_response(r2)&#10;        if ok2:&#10;            return (True, resp2)&#10;        # retornar a melhor mensagem possível (prioriza r2, depois r, depois exceção)&#10;        if r2 is not None and getattr(r2, &quot;text&quot;, None):&#10;            return (False, r2.text)&#10;    except Exception as e_post:&#10;        # se POST falhar, relatar ambos erros se existirem&#10;        msg = &quot;&quot;&#10;        if err_get:&#10;            msg += f&quot;GET erro: {err_get}. &quot;&#10;        msg += f&quot;POST erro: {str(e_post)}&quot;&#10;        return (False, msg)&#10;&#10;    # sem sucesso nos dois&#10;    if r is not None and getattr(r, &quot;text&quot;, None):&#10;        return (False, r.text)&#10;    if err_get:&#10;        return (False, err_get)&#10;    return (False, &quot;Resposta inesperada do servidor.&quot;)&#10;&#10;# Compatibilidade com cores entre versões:&#10;try:&#10;    colors = ft.colors    # versão mais nova&#10;except Exception:&#10;    try:&#10;        colors = ft.Colors  # fallback&#10;    except Exception:&#10;        colors = None  # raríssimo: fallback genérico&#10;&#10;# Import de player de áudio com fallback&#10;# flet_audio pode expor FletAudio (nomes variam entre versões)&#10;FLET_AUDIO_AVAILABLE = False&#10;try:&#10;    from flet_audio import FletAudio  # pacote flet-audio (nome comum)&#10;    FLET_AUDIO_AVAILABLE = True&#10;except Exception:&#10;    # fallback: talvez ft.Audio exista (algumas builds)&#10;    try:&#10;        _ = ft.Audio  # verifica existência&#10;        FLET_AUDIO_AVAILABLE = False  # usaremos ft.Audio como fallback ad-hoc&#10;    except Exception:&#10;        FLET_AUDIO_AVAILABLE = False&#10;&#10;# Caminhos de assets (relativos)&#10;ASSET_LOGO = &quot;logo.png&quot;&#10;ASSET_MUSICS = [&#10;    &quot;musics/music_game.mp3&quot;,&#10;    &quot;musics/pergunta1.mp3&quot;,&#10;    &quot;musics/acerto.mp3&quot;,&#10;    &quot;musics/lose.mp3&quot;,&#10;    &quot;musics/win.mp3&quot;,&#10;]&#10;&#10;&#10;class MusicaPlayer:&#10;    def __init__(self, page: ft.Page):&#10;        self.page = page&#10;        self.player = None&#10;&#10;        # Tenta criar FletAudio se disponível&#10;        try:&#10;            if 'FletAudio' in globals() and globals().get(&quot;FletAudio&quot;):&#10;                self.player = FletAudio(src=&quot;&quot;, autoplay=False)&#10;            else:&#10;                # fallback: usar ft.Audio se disponível&#10;                if hasattr(ft, &quot;Audio&quot;):&#10;                    self.player = ft.Audio(src=&quot;&quot;, autoplay=False)&#10;                else:&#10;                    self.player = None&#10;        except Exception:&#10;            self.player = None&#10;&#10;        if self.player is not None and self.player not in self.page.overlay:&#10;            try:&#10;                self.page.overlay.append(self.player)&#10;            except Exception:&#10;                pass&#10;&#10;    def tocar(self, i=0):&#10;        if not self.player:&#10;            return&#10;        try:&#10;            idx = int(i) if isinstance(i, int) else 0&#10;            idx = max(0, min(idx, len(ASSET_MUSICS) - 1))&#10;            src = ASSET_MUSICS[idx]&#10;            # garante caminho relativo (sem leading slash)&#10;            src = src.lstrip(&quot;/&quot;)&#10;            self.player.src = src&#10;            # autoplay pode não ser aceito por todas as classes; tente setar e update&#10;            try:&#10;                self.player.autoplay = True&#10;            except Exception:&#10;                pass&#10;            try:&#10;                self.page.update()&#10;            except Exception:&#10;                pass&#10;        except Exception:&#10;            # não deixar quebrar a aplicação por erro de áudio&#10;            print(&quot;Erro ao tocar áudio:&quot;, traceback.format_exc())&#10;&#10;# Removido: antiga definição de TelaRegistro que herdava ft.Column (substituída por UserControl mais acima)&#10;&#10;# Removido: antiga definição de TelaLogin que herdava ft.Column (substituída por UserControl mais acima)&#10;&#10;class ShowDoMilhao:&#10;    def __init__(self, page: ft.Page, on_logout=None, user_id=None):&#10;        self.page = page&#10;        # callback para voltar à tela de entrada (login/registro)&#10;        self.on_logout = on_logout&#10;        # user_id (matrícula ou identificador) para persistir acertos por usuário&#10;        self.user_id = user_id&#10;        try:&#10;            self.page.title = &quot;Show do Coutão&quot;&#10;            self.page.bgcolor = &quot;#002e5c&quot;&#10;        except Exception:&#10;            pass&#10;        self.musica = MusicaPlayer(page)&#10;        self.pontos = 0&#10;        self.checkpoint = 0&#10;        self.perguntas_jogo = []&#10;        self.pergunta_atual = None&#10;        self.indice = 0&#10;        self.ajuda_usada = False&#10;        self.troca_usada = False&#10;        self.ajuda_professor_usada = False&#10;        self.labels_regua = []&#10;        self.botoes = []&#10;        # Lista para armazenar as perguntas que o jogador já acertou&#10;        # carregar acertos persistidos do usuário (se houver)&#10;        if self.user_id:&#10;            self.perguntas_acertadas = list(get_acertos_for_user(self.user_id))&#10;        else:&#10;            self.perguntas_acertadas = []&#10;        self.tela_inicial()&#10;&#10;    # helpers para compatibilidade de ButtonStyle entre versões&#10;    def _make_button_style(self):&#10;        # Tentamos usar text_style (nova API). Se der TypeError, tentamos textstyle.&#10;        try:&#10;            return ft.ButtonStyle(&#10;                text_style=ft.TextStyle(size=28, weight=ft.FontWeight.BOLD)&#10;            )&#10;        except TypeError:&#10;            try:&#10;                return ft.ButtonStyle(&#10;                    textstyle=ft.TextStyle(size=28, weight=ft.FontWeight.BOLD)&#10;                )&#10;            except Exception:&#10;                # fallback simples&#10;                return None&#10;        except Exception:&#10;            return None&#10;&#10;    def tela_inicial(self):&#10;        try:&#10;            self.musica.tocar(0)&#10;        except Exception:&#10;            pass&#10;        self.page.clean()&#10;        # garantir estado inicial limpo&#10;&#10;        # tenta embutir a imagem como data URI para garantir exibição&#10;        def _get_logo_src():&#10;            try:&#10;                p = Path(ASSET_LOGO)&#10;                if p.exists():&#10;                    b = p.read_bytes()&#10;                    mime = &quot;image/png&quot;&#10;                    # inferir por extensão simples&#10;                    if p.suffix.lower() in [&quot;.jpg&quot;, &quot;.jpeg&quot;]:&#10;                        mime = &quot;image/jpeg&quot;&#10;                    elif p.suffix.lower() == &quot;.gif&quot;:&#10;                        mime = &quot;image/gif&quot;&#10;                    data = base64.b64encode(b).decode(&quot;ascii&quot;)&#10;                    return f&quot;data:{mime};base64,{data}&quot;&#10;            except Exception:&#10;                pass&#10;            # fallback: caminho direto (requer assets_dir configurado)&#10;            return ASSET_LOGO&#10;&#10;        # aumentar tamanho do logo&#10;        logo = ft.Image(src=_get_logo_src(), width=900, height=450, fit=ft.ImageFit.CONTAIN)&#10;        botao_style = self._make_button_style()&#10;        botao_jogar = ft.ElevatedButton(&#10;            &quot;Jogar&quot;,&#10;            on_click=self.iniciar_jogo,&#10;            bgcolor=(colors.BLUE if colors is not None else None),&#10;            color=(colors.WHITE if colors is not None else None),&#10;            width=300,&#10;            height=70,&#10;            style=botao_style&#10;        )&#10;        # &quot;Sair&quot; deve apenas deslogar: chamar on_logout para voltar ao login/registro&#10;        def _sair_inicial(e):&#10;            # tenta chamar callback de logout, se fornecido&#10;            try:&#10;                if callable(getattr(self, &quot;on_logout&quot;, None)):&#10;                    return self.on_logout()&#10;            except Exception:&#10;                pass&#10;            # fallback: limpar e mostrar uma tela simples que retorna para tela_inicial&#10;            try:&#10;                self.page.clean()&#10;            except Exception:&#10;                pass&#10;            try:&#10;                col = ft.Column(&#10;                    [&#10;                        ft.Text(&quot;Você saiu do jogo&quot;, size=20, weight=ft.FontWeight.BOLD),&#10;                        ft.ElevatedButton(&quot;Voltar&quot;, on_click=lambda ev: self.tela_inicial(), width=220)&#10;                    ],&#10;                    alignment=ft.MainAxisAlignment.CENTER,&#10;                    horizontal_alignment=ft.CrossAxisAlignment.CENTER,&#10;                    spacing=16&#10;                )&#10;                self.page.add(ft.Container(content=col, alignment=ft.alignment.center, expand=True))&#10;                try:&#10;                    self.page.update()&#10;                except Exception:&#10;                    pass&#10;            except Exception:&#10;                # evitar crash caso o fallback falhe&#10;                pass&#10;&#10;        botao_sair = ft.ElevatedButton(&#10;            &quot;Sair&quot;,&#10;            on_click=_sair_inicial,&#10;            bgcolor=(colors.RED if colors is not None else None),&#10;            color=(colors.WHITE if colors is not None else None),&#10;            width=300,&#10;            height=70,&#10;            style=botao_style&#10;        )&#10;&#10;        botao_minhas = None&#10;        if getattr(self, &quot;user_id&quot;, None):&#10;            botao_minhas = ft.ElevatedButton(&#10;                &quot;Minhas Respostas&quot;,&#10;                on_click=self.mostrar_acertos,&#10;                bgcolor=(colors.BROWN if colors is not None else None),&#10;                color=(colors.WHITE if colors is not None else None),&#10;                width=300,&#10;                height=70&#10;            )&#10;&#10;        # montar linha de botões: se houver botao_minhas, incluí-lo entre Jogar e Sair&#10;        row_buttons = [botao_jogar]&#10;        if botao_minhas:&#10;            row_buttons.append(botao_minhas)&#10;        row_buttons.append(botao_sair)&#10;&#10;        col = ft.Column([&#10;            logo,&#10;            ft.Row(row_buttons, alignment=ft.MainAxisAlignment.CENTER)&#10;        ], alignment=ft.MainAxisAlignment.CENTER, horizontal_alignment=ft.CrossAxisAlignment.CENTER, spacing=24)&#10;        # envolver em Container expandido para centralizar também verticalmente&#10;        self.page.add(ft.Container(content=col, alignment=ft.alignment.center, expand=True))&#10;&#10;    def iniciar_jogo(self, e=None):&#10;        import traceback as _tb&#10;        print(&quot;[DEBUG] iniciar_jogo chamado&quot;)&#10;        try:&#10;            try:&#10;                self.musica.tocar(1)&#10;            except Exception:&#10;                pass&#10;            self.pontos = 0&#10;            # NÃO resetar persistência global dos acertos do usuário; manter histórico&#10;            # inicia jogo: limpar página e construir a interface do jogo&#10;            try:&#10;                self.page.clean()&#10;            except Exception:&#10;                pass&#10;            self.ajuda_usada = False&#10;            self.troca_usada = False&#10;            self.ajuda_professor_usada = False&#10;            # importa perguntas dinamicamente para evitar import circular no topo&#10;            try:&#10;                from perguntas import facil&#10;                self.perguntas_jogo = random.sample(facil, min(10, len(facil)))&#10;            except Exception:&#10;                self.perguntas_jogo = []&#10;            self.tela_jogo()&#10;        except Exception as exc:&#10;            tb = _tb.format_exc()&#10;            print(&quot;[ERROR] Exception em iniciar_jogo:\n&quot;, tb)&#10;            # mostra diálogo com erro para evitar tela cinza&#10;            try:&#10;                dlg = ft.AlertDialog(title=ft.Text(&quot;Erro ao iniciar jogo&quot;), content=ft.Text(&quot;Ocorreu um erro ao iniciar o jogo. Veja o console.&quot;), actions=[ft.TextButton(&quot;OK&quot;, on_click=lambda e: self._fechar_dialog(dlg))])&#10;                self.page.dialog = dlg&#10;                if dlg not in self.page.overlay:&#10;                    self.page.overlay.append(dlg)&#10;                dlg.open = True&#10;                try:&#10;                    self.page.update()&#10;                except Exception:&#10;                    pass&#10;            except Exception:&#10;                pass&#10;            return&#10;&#10;    def tela_jogo(self):&#10;        self.page.clean()&#10;        self.labels_regua = []&#10;        regua = []&#10;        for i in range(len(self.perguntas_jogo)):&#10;            texto = f&quot;{i + 1}&quot;&#10;            icone = &quot;&quot;&#10;            cor_fundo = (colors.BLUE_900 if colors is not None else None)&#10;            cor_texto = (colors.WHITE if colors is not None else None)&#10;            bolinha = ft.Container(&#10;                content=ft.Text(texto, size=16, color=cor_texto, weight=ft.FontWeight.BOLD),&#10;                width=36,&#10;                height=36,&#10;                bgcolor=cor_fundo,&#10;                border=ft.border.all(3, (colors.YELLOW if (colors is not None) else None)),&#10;                border_radius=18,&#10;                alignment=ft.alignment.center,&#10;                margin=ft.margin.only(right=0)&#10;            )&#10;            if i + 1 in [3, 5, 8]:&#10;                icone = &quot;&quot;&#10;            elif i + 1 == 10:&#10;                icone = &quot;&quot;&#10;            item = ft.Row([&#10;                bolinha,&#10;                ft.Text(icone, size=18, color=cor_texto) if icone else ft.Text(&quot;&quot;)&#10;            ], alignment=ft.MainAxisAlignment.CENTER, spacing=2)&#10;            regua.append(item)&#10;        self.labels_regua = regua&#10;        self.label_pergunta = ft.Text(&quot;&quot;, size=18, color=(colors.YELLOW if colors is not None else None), weight=ft.FontWeight.BOLD)&#10;        self.botoes = []&#10;        for i in range(4):&#10;            botao = ft.ElevatedButton(&#10;                &quot;...&quot;,&#10;                width=500,&#10;                bgcolor=(colors.BLUE if colors is not None else None),&#10;                color=(colors.WHITE if colors is not None else None),&#10;                on_click=lambda e, i=i: self.verificar_resposta(i)&#10;            )&#10;            self.botoes.append(botao)&#10;        self.label_feedback = ft.Text(&quot;&quot;, size=16, color=(colors.WHITE if colors is not None else None))&#10;        self.label_saldo = ft.Text(f&quot;Saldo atual: R${self.pontos}&quot;, size=16, color=(colors.CYAN if colors is not None else None))&#10;        self.botao_ajuda = ft.ElevatedButton(&#10;            &quot;Rodar Dados&quot;,&#10;            bgcolor=(colors.PURPLE if colors is not None else None),&#10;            color=(colors.WHITE if colors is not None else None),&#10;            width=160,&#10;            on_click=self.ajuda_dado&#10;        )&#10;        self.botao_troca = ft.ElevatedButton(&#10;            &quot;Trocar Pergunta&quot;,&#10;            bgcolor=(colors.GREEN_900 if colors is not None else None),&#10;            color=(colors.WHITE if colors is not None else None),&#10;            width=160,&#10;            on_click=self.trocar_pergunta&#10;        )&#10;        self.botao_professor = ft.ElevatedButton(&#10;            &quot;Ajuda dos Professores&quot;,&#10;            bgcolor=(colors.ORANGE_900 if colors is not None else None),&#10;            color=(colors.WHITE if colors is not None else None),&#10;            width=160,&#10;            on_click=self.ajuda_professor&#10;        )&#10;&#10;        # Sair deve apenas deslogar: chamar on_logout para voltar ao login/registro&#10;        def _sair_jogo(e):&#10;            # tenta executar callback de logout, se fornecido&#10;            try:&#10;                if callable(getattr(self, &quot;on_logout&quot;, None)):&#10;                    return self.on_logout()&#10;            except Exception:&#10;                pass&#10;            # fallback: limpar e mostrar uma tela simples que retorna para tela_inicial&#10;            try:&#10;                self.page.clean()&#10;            except Exception:&#10;                pass&#10;            try:&#10;                col = ft.Column(&#10;                    [&#10;                        ft.Text(&quot;Você saiu do jogo&quot;, size=20, weight=ft.FontWeight.BOLD),&#10;                        ft.ElevatedButton(&quot;Voltar&quot;, on_click=lambda ev: self.tela_inicial(), width=220)&#10;                    ],&#10;                    alignment=ft.MainAxisAlignment.CENTER,&#10;                    horizontal_alignment=ft.CrossAxisAlignment.CENTER,&#10;                    spacing=16&#10;                )&#10;                self.page.add(ft.Container(content=col, alignment=ft.alignment.center, expand=True))&#10;                try:&#10;                    self.page.update()&#10;                except Exception:&#10;                    pass&#10;            except Exception:&#10;                # evitar crash caso o fallback falhe&#10;                pass&#10;&#10;        self.botao_sair = ft.ElevatedButton(&quot;Sair&quot;, bgcolor=(colors.RED if colors is not None else None), color=(colors.WHITE if colors is not None else None), on_click=_sair_jogo)&#10;        self.botao_desistir = ft.ElevatedButton(&quot;Desistir&quot;, on_click=self.desistir)&#10;        self.page.add(&#10;            ft.Row([&#10;                ft.Column([&#10;                    self.label_pergunta,&#10;                    *self.botoes,&#10;                    # ajudas (sem o botão &quot;Minhas Respostas&quot;, que fica na tela inicial)&#10;                    ft.Row([self.botao_ajuda, self.botao_troca, self.botao_professor]),&#10;                    self.label_feedback,&#10;                    self.label_saldo,&#10;                    ft.Row([self.botao_desistir, self.botao_sair]),&#10;                ], alignment=ft.MainAxisAlignment.START),&#10;                ft.Column(regua, alignment=ft.MainAxisAlignment.START, spacing=0)&#10;            ], alignment=ft.MainAxisAlignment.CENTER)&#10;        )&#10;        self.carregar_pergunta()&#10;&#10;    def mostrar_acertos(self, e=None):&#10;        &quot;&quot;&quot;Mostra uma tela com as perguntas já acertadas e o conteúdo da ajuda do professor.&#10;        Usa os acertos persistidos do usuário (se houver user_id).&quot;&quot;&quot;&#10;        try:&#10;            self.page.clean()&#10;        except Exception:&#10;            pass&#10;        controls = []&#10;        # carregar acertos persistidos (prioriza armazenamento persistente)&#10;        acertos = self.perguntas_acertadas&#10;        if self.user_id:&#10;            try:&#10;                acertos = get_acertos_for_user(self.user_id) or []&#10;            except Exception:&#10;                pass&#10;        if not acertos:&#10;            controls.append(ft.Text(&quot;Nenhuma pergunta acertada ainda.&quot;, size=18, color=(colors.WHITE if colors is not None else None)))&#10;        else:&#10;            for idx, item in enumerate(acertos, start=1):&#10;                texto_pergunta = item.get(&quot;pergunta&quot;, &quot;Pergunta sem texto&quot;)&#10;                texto_ajuda = item.get(&quot;ajuda&quot;, &quot;Sem ajuda disponível.&quot;)&#10;                texto_correta = item.get(&quot;correta_texto&quot;, &quot;&quot;)&#10;                bloco = ft.Container(&#10;                    content=ft.Column([&#10;                        ft.Text(f&quot;{idx}. {texto_pergunta}&quot;, size=16, weight=ft.FontWeight.BOLD, selectable=True),&#10;                        ft.Text(f&quot;Resposta correta: {texto_correta}&quot;, size=14, color=(colors.CYAN if colors is not None else None)),&#10;                        ft.Text(f&quot;Ajuda dos Professores: {texto_ajuda}&quot;, size=14, selectable=True)&#10;                    ], spacing=6),&#10;                    padding=ft.padding.all(10),&#10;                    margin=ft.margin.only(bottom=8),&#10;                    bgcolor=(colors.BLUE_950 if colors is not None else None)&#10;                )&#10;                controls.append(bloco)&#10;&#10;        botao_voltar = ft.ElevatedButton(&quot;Voltar ao jogo&quot;, on_click=lambda _: self.tela_jogo(), width=200)&#10;        self.page.add(&#10;            ft.Container(&#10;                content=ft.Column(&#10;                    [ft.Text(&quot;Minhas Respostas&quot;, size=22, weight=ft.FontWeight.BOLD), *controls, botao_voltar],&#10;                    alignment=ft.MainAxisAlignment.START,&#10;                    spacing=12&#10;                ),&#10;                padding=ft.padding.all(20),&#10;                expand=True,&#10;                alignment=ft.alignment.center&#10;            )&#10;        )&#10;        try:&#10;            self.page.update()&#10;        except Exception:&#10;            pass&#10;&#10;    # helpers de texto para dividir questão/ajuda&#10;    def dividir_pergunta(self, texto, limite=90):&#10;        if len(texto) &lt;= limite:&#10;            return texto, &quot;&quot;&#10;        idx = texto.rfind(&quot; &quot;, 0, limite)&#10;        if idx == -1:&#10;            idx = limite&#10;        return texto[:idx], texto[idx:].lstrip()&#10;&#10;    def dividir_ajuda(self, texto, limite=60):&#10;        if len(texto) &lt;= limite:&#10;            return texto&#10;        idx = texto.rfind(&quot; &quot;, 0, limite)&#10;        if idx == -1:&#10;            idx = limite&#10;        return texto[:idx] + &quot;\n&quot; + texto[idx:].lstrip()&#10;&#10;    def carregar_pergunta(self):&#10;        try:&#10;            self.musica.tocar(1)&#10;        except Exception:&#10;            pass&#10;        if self.indice &lt; len(self.perguntas_jogo):&#10;            self.pergunta_atual = self.perguntas_jogo[self.indice]&#10;            alternativas = self.pergunta_atual[&quot;alternativas&quot;][:]&#10;            correta = self.pergunta_atual[&quot;correta&quot;]&#10;            alternativas_com_indices = list(enumerate(alternativas))&#10;            random.shuffle(alternativas_com_indices)&#10;            alternativas_embaralhadas = [alt for idx, alt in alternativas_com_indices]&#10;            # novo índice da correta após embaralhar&#10;            nova_correta = [idx for idx, alt in alternativas_com_indices].index(correta)&#10;            self.pergunta_atual[&quot;alternativas_embaralhadas&quot;] = alternativas_embaralhadas&#10;            self.pergunta_atual[&quot;nova_correta&quot;] = nova_correta&#10;            texto1, texto2 = self.dividir_pergunta(self.pergunta_atual[&quot;pergunta&quot;], limite=500)&#10;            texto_completo = texto1 + (&quot;\n&quot; + texto2 if texto2 else &quot;&quot;)&#10;            pergunta_principal = ft.Container(&#10;                content=ft.Text(texto_completo, size=18, color=(colors.YELLOW if colors is not None else None), weight=ft.FontWeight.BOLD, selectable=True),&#10;                width=500,&#10;                alignment=ft.alignment.center,&#10;                padding=ft.padding.all(10),&#10;                bgcolor=None&#10;            )&#10;            self.label_pergunta = pergunta_principal&#10;            for i, alt in enumerate(alternativas_embaralhadas):&#10;                self.botoes[i].text = alt&#10;                self.botoes[i].disabled = False&#10;            self.label_feedback.value = &quot;&quot;&#10;            self.label_saldo.value = f&quot;Saldo atual: R${self.pontos}&quot;&#10;            for i, item in enumerate(self.labels_regua):&#10;                bolinha = item.controls[0]&#10;                try:&#10;                    bolinha.bgcolor = (colors.GREEN_700 if i &lt; self.indice else (colors.YELLOW_300 if i == self.indice else colors.BLUE_900))&#10;                    bolinha.border = ft.border.all(3, (colors.YELLOW if i == self.indice else colors.WHITE))&#10;                    bolinha.content.color = (colors.BLACK if i == self.indice else colors.WHITE)&#10;                except Exception:&#10;                    pass&#10;            self.page.clean()&#10;            self.page.add(&#10;                ft.Row([&#10;                    ft.Column([&#10;                        self.label_pergunta,&#10;                        *self.botoes,&#10;                        # incluir o botão de acertos ao lado das ajudas&#10;                        ft.Row([self.botao_ajuda, self.botao_troca, self.botao_professor]),&#10;                        self.label_feedback,&#10;                        self.label_saldo,&#10;                        ft.Row([self.botao_desistir, self.botao_sair]),&#10;                    ], alignment=ft.MainAxisAlignment.START),&#10;                    ft.Column(self.labels_regua, alignment=ft.MainAxisAlignment.START, spacing=0)&#10;                ], alignment=ft.MainAxisAlignment.CENTER)&#10;            )&#10;            try:&#10;                self.page.update()&#10;            except Exception:&#10;                pass&#10;        else:&#10;            self.vitoria()&#10;&#10;    def trocar_pergunta(self, e=None):&#10;        if self.troca_usada:&#10;            return&#10;        self.troca_usada = True&#10;        try:&#10;            self.botao_troca.visible = False&#10;            self.page.update()&#10;        except Exception:&#10;            pass&#10;        try:&#10;            from perguntas import facil&#10;            perguntas_possiveis = [p for p in facil if p not in self.perguntas_jogo]&#10;        except Exception:&#10;            perguntas_possiveis = []&#10;        if perguntas_possiveis:&#10;            nova_pergunta = random.choice(perguntas_possiveis)&#10;            self.perguntas_jogo[self.indice] = nova_pergunta&#10;            self.label_feedback.value = &quot; Pergunta trocada!&quot;&#10;            try:&#10;                self.label_feedback.color = (colors.GREEN_900 if colors is not None else None)&#10;            except Exception:&#10;                pass&#10;            self.carregar_pergunta()&#10;        else:&#10;            self.label_feedback.value = &quot;Não há perguntas disponíveis para troca.&quot;&#10;            try:&#10;                self.label_feedback.color = colors.RED&#10;            except Exception:&#10;                pass&#10;        try:&#10;            self.page.update()&#10;        except Exception:&#10;            pass&#10;&#10;    def ajuda_dado(self, e=None):&#10;        if self.ajuda_usada:&#10;            return&#10;        self.ajuda_usada = True&#10;        try:&#10;            self.botao_ajuda.visible = False&#10;            self.page.update()&#10;        except Exception:&#10;            pass&#10;        correta = self.pergunta_atual[&quot;nova_correta&quot;]&#10;        alternativas_restantes = [i for i in range(4) if i != correta and not self.botoes[i].disabled]&#10;        qtd_eliminar = min(random.randint(1, 3), len(alternativas_restantes))&#10;        eliminar = random.sample(alternativas_restantes, qtd_eliminar)&#10;        for i in eliminar:&#10;            self.botoes[i].disabled = True&#10;            self.botoes[i].text = &quot; &quot;&#10;        self.label_feedback.value = f&quot; Dado rolado: {qtd_eliminar} alternativas eliminadas.&quot;&#10;        try:&#10;            self.label_feedback.color = (colors.PURPLE if colors is not None else None)&#10;        except Exception:&#10;            pass&#10;        try:&#10;            self.page.update()&#10;        except Exception:&#10;            pass&#10;&#10;    def ajuda_professor(self, e=None):&#10;        if self.ajuda_professor_usada:&#10;            return&#10;        self.ajuda_professor_usada = True&#10;        try:&#10;            self.botao_professor.visible = False&#10;            self.page.update()&#10;        except Exception:&#10;            pass&#10;        texto_ajuda = self.pergunta_atual.get(&quot;ajuda&quot;, &quot;‍ Os professores sugerem que você pense bem antes de responder!&quot;)&#10;        texto_ajuda = self.dividir_ajuda(texto_ajuda, limite=38)&#10;        self.label_feedback.value = f&quot;‍ Ajuda dos Professores: {texto_ajuda}&quot;&#10;        try:&#10;            self.label_feedback.color = (colors.RED if colors is not None else None)&#10;        except Exception:&#10;            pass&#10;        try:&#10;            self.page.update()&#10;        except Exception:&#10;            pass&#10;&#10;    def verificar_resposta(self, escolha):&#10;        for botao in self.botoes:&#10;            botao.disabled = True&#10;        try:&#10;            correta = int(self.pergunta_atual[&quot;nova_correta&quot;])&#10;        except Exception:&#10;            correta = None&#10;        if correta is None:&#10;            # não sabemos a correta; apenas avançar para próxima pergunta&#10;            try:&#10;                self.label_feedback.value = &quot;Erro interno: pergunta sem alternativa correta.&quot;&#10;            except Exception:&#10;                pass&#10;            try:&#10;                self.page.update()&#10;            except Exception:&#10;                pass&#10;            return&#10;&#10;        if escolha == correta:&#10;            try:&#10;                self.musica.tocar(2)&#10;            except Exception:&#10;                pass&#10;            # registrar pergunta acertada (guarda texto da pergunta, ajuda e texto da resposta correta)&#10;            try:&#10;                correta_texto = &quot;&quot;&#10;                if isinstance(self.pergunta_atual.get(&quot;alternativas&quot;), list) and isinstance(self.pergunta_atual.get(&quot;correta&quot;), int):&#10;                    correta_texto = self.pergunta_atual[&quot;alternativas&quot;][self.pergunta_atual[&quot;correta&quot;]]&#10;                acerto_item = {&#10;                    &quot;pergunta&quot;: self.pergunta_atual.get(&quot;pergunta&quot;, &quot;&quot;),&#10;                    &quot;ajuda&quot;: self.pergunta_atual.get(&quot;ajuda&quot;, &quot;&quot;),&#10;                    &quot;correta_texto&quot;: correta_texto&#10;                }&#10;                self.perguntas_acertadas.append(acerto_item)&#10;                try:&#10;                    if self.user_id:&#10;                        add_acerto_for_user(self.user_id, acerto_item)&#10;                except Exception:&#10;                    pass&#10;            except Exception:&#10;                pass&#10;&#10;            self.pontos += 1000&#10;            if (self.indice + 1) in [3, 5, 8]:&#10;                self.checkpoint = self.pontos&#10;            try:&#10;                self.label_feedback.value = f&quot;✅ Correto! Ganhou R$1000&quot;&#10;            except Exception:&#10;                pass&#10;            # avançar para próxima pergunta&#10;            self.indice += 1&#10;            if self.indice &lt; len(self.perguntas_jogo):&#10;                try:&#10;                    self.carregar_pergunta()&#10;                except Exception:&#10;                    pass&#10;            else:&#10;                try:&#10;                    self.vitoria()&#10;                except Exception:&#10;                    pass&#10;        else:&#10;            # resposta incorreta: acionar rotina de derrota/atraso se existir&#10;            try:&#10;                self.page.run_task(self._delay_derrota)&#10;            except Exception:&#10;                try:&#10;                    # fallback síncrono&#10;                    self._delay_derrota()&#10;                except Exception:&#10;                    pass&#10;        try:&#10;            self.page.update()&#10;        except Exception:&#10;            pass&#10;&#10;# Adicionado: entrypoint e inicialização do servidor Flet (útil para deployment em Railway)&#10;def main(page: ft.Page):&#10;    &quot;&quot;&quot;&#10;    Entrypoint para Flet. Cria a instância do jogo e exibe a tela inicial.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Opcional: definir título/cores padrão se necessário&#10;        try:&#10;            page.title = &quot;Show do Coutão (Servidor)&quot;&#10;            page.bgcolor = &quot;#002e5c&quot;&#10;        except Exception:&#10;            pass&#10;&#10;        # Cria a aplicação do jogo; ShowDoMilhao já executa tela_inicial no construtor&#10;        ShowDoMilhao(page)&#10;        try:&#10;            page.update()&#10;        except Exception:&#10;            pass&#10;    except Exception as e:&#10;        # Log para diagnosticar problemas de startup&#10;        print(&quot;Erro durante inicialização da UI:&quot;, str(e))&#10;        import traceback&#10;        print(traceback.format_exc())&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    # Porta que o Railway (ou outro PaaS) fornece via env var PORT&#10;    try:&#10;        port_env = os.environ.get(&quot;PORT&quot;) or os.environ.get(&quot;PORT0&quot;) or &quot;8550&quot;&#10;        port = int(port_env)&#10;    except Exception:&#10;        port = 8550&#10;&#10;    assets = str(Path(__file__).parent)&#10;&#10;    print(f&quot;Iniciando Flet app em 0.0.0.0:{port} com assets_dir={assets}&quot;)&#10;    try:&#10;        ft.app(&#10;            target=main,&#10;            view=ft.WEB_BROWSER,&#10;            host=&quot;0.0.0.0&quot;,&#10;            port=port,&#10;            assets_dir=assets&#10;        )&#10;    except Exception as e:&#10;        print(&quot;Falha ao iniciar ft.app():&quot;, str(e))&#10;        import traceback&#10;        print(traceback.format_exc())&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>